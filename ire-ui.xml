<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>ire-ui</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>ire-ui</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>IRE</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>IRE.core</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Login Trigger</name>
						<script>-----
--@Description Raises a login event upon logging in successfully
-----
raiseEvent("IRE.core.login")

-----
--@Description Enabling game specific elements
-----</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Password correct. Welcome to</string>
							<string>^Password correct. Welcome to (\w+).$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ire-ui</name>
			<packageName>ire-ui</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Drag and Drop GUI Framework</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 10/02/2018
-- v1.3.3

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)

GUIframe.configs = GUIframe.configs or {}

GUIframe.defaults = {
    tabHeight = 20,
    tabStyle = [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color = white"&gt;',
    leftStartWidth = 0,
    leftStartHeight = halfH,
    rightStartWidth = 0,
    rightStartHeight = halfH,
    topStartHeight = 0,
    bottomStartHeight = 0,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_30t.png",
    borderOffset = 5,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo = {
    topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
        height = configs.tabHeight},
    bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
        width = configs.leftStartWidth, height = configs.tabHeight},
    topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
        width = configs.rightStartWidth, height = configs.tabHeight},
    bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
        y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
}
local containerInfo = {
    topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
        width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
    bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
        width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
    topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
        y = configs.tabHeight, width = configs.rightStartWidth,
        height = configs.rightStartHeight - configs.tabHeight},
    bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
        y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
        height = configs.rightStartHeight - configs.tabHeight},
    bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
        y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
        width = mainW - configs.leftStartWidth - configs.rightStartWidth},
    topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
        width = mainW - configs.leftStartWidth - configs.rightStartWidth}
}
local resizeInfo = {
    resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
        y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
        width = configs.resizeWidth},
    resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
        y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
        width = configs.resizeWidth},
    resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
        y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
    resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
        y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
        width = configs.resizeWidth}
}

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}
    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end
    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    setBorderRight(configs.rightStartWidth + configs.borderOffset)
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
	        tab:echo(configs.tabEchoStyle..tab.name:gsub("Tab",""))
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, wname)
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(getMudletHomeDir() .. "/GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = getMudletHomeDir() .. "/GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
        local tabs = {}
        for _,name in ipairs(wins) do
            table.insert(tabs, name.."Tab")
            GUIframe.addWindow(GUIframe.windows[name], name, con)
        end
        local tabCon = GUIframe[con].tabs
        if tabCon then
            tabCon.windows = tabs
            adjustTabs(tabCon)
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""))
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    lbl = GUIframe[name]
	    if lbl.isClicked then
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Barebones IRE framework</name>
				<packageName></packageName>
				<script>registerAnonymousEventHandler("sysLoadEvent", "GUIframe.loadSettings")
registerAnonymousEventHandler("sysExitEvent", "GUIframe.saveSettings")
local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW / 2), math.floor(mainH / 2)
GUIframe.configs =
  {
    tabHeight = 20,
    tabStyle =
      [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color = white"&gt;',
    leftStartWidth = 450,
    leftStartHeight = halfH,
    rightStartWidth = 400,
    rightStartHeight = halfH,
    topStartHeight = 0,
    bottomStartHeight = 110,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/ire-ui/img/blue_arrows.png",
    resizeRestImage = "/ire-ui/img/blue_arrows_30t.png",
    borderOffset = 5,
  }
mapper = Geyser.Mapper:new({name = "myMapper"})
chat = Geyser.MiniConsole:new({name = "Chat", autoWrap = true, color = "black"})
characterinfo =
  Geyser.Label:new(
    {
      name = "RedBox",
      color = "red",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Things about me go here&lt;/center&gt;",
    }
  )
skills =
  Geyser.Label:new(
    {
      name = "BlueBox",
      color = "blue",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Skills go here&lt;/center&gt;",
    }
  )
inventory =
  Geyser.Label:new(
    {
      name = "GreenBox",
      color = "brown",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Inventory goes here&lt;/center&gt;",
    }
  )
roominfo =
  Geyser.Label:new(
    {
      name = "OrangeBox",
      color = "orange",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Room info goes here&lt;/center&gt;",
    }
  )
online =
  Geyser.Label:new(
    {
      name = "YellowBox",
      color = "pink",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;List of online players goes here&lt;/center&gt;",
    }
  )
quests =
  Geyser.Label:new(
    {
      name = "YellowBox2",
      color = "gold",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Quests go here&lt;/center&gt;",
    }
  )
vitals =
  Geyser.Label:new(
    {
      name = "Vitals",
      color = "black",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
--      message = "&lt;center&gt;Character stats go here&lt;/center&gt;",
    }
  )
GUIframe.addWindow(mapper, "Map", "topleft")
GUIframe.addWindow(characterinfo, "Me", "bottomleft")
GUIframe.addWindow(skills, "Skills", "bottomleft")
GUIframe.addWindow(inventory, "Inventory", "bottomleft")
GUIframe.addWindow(roominfo, "Room info", "topright")
GUIframe.addWindow(online, "Online", "topright")
GUIframe.addWindow(quests, "Quests", "bottomright")
GUIframe.addWindow(chat, "Chat", "bottomright")
GUIframe.addWindow(vitals, "Vitals", "bottom")
GUIframe.disable("top", true)</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>IRE</name>
				<packageName></packageName>
				<script>------
--@Description The base namespace table for Iron Realms Entertainment
------
IRE = IRE or {}

---------
--Version
---------
IRE.version = IRE.version or {
  display = "0.1.0",
  major = 0,
  minor = 1,
  bugfix = 0
}</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>IRE.gmcp</name>
					<packageName></packageName>
					<script>------
--@Description The table for gmcp handling for iron realms games
------
IRE.gmcp = IRE.gmcp or {}</script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>IRE.gmcp.char</name>
						<packageName></packageName>
						<script>------
--@Description The table for gmcp character data handling
------
IRE.gmcp.char = IRE.gmcp.char or {}</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>IRE.gmcp.char.items_add</name>
							<packageName></packageName>
							<script>-----
--@Description Processes gmcp.Char.Items.Add, adding an item to the local room inventory or character inventory
--@Event IRE.core.inventory.add Raised when the character inventory receives an item.
-- Passes the item as defined by gmcp.Char.Items.Add.item as its argument.
--@Event IRE.core.room.inventoryAdd Raised when the room inventory receives an item.
-- Passes the item as defined by gmcp.Char.Items.Add.item as its argument.
-----
function IRE.gmcp.char.items_add()
	if gmcp.Char.Items.Add.location == "inv" 
	then
		IRE.core.inventory.addItem(gmcp.Char.Items.Add.item)
    raiseEvent("IRE.core.inventory.add",gmcp.Char.Items.Add.item)
  elseif gmcp.Char.Items.Add.location == "room"
  then
		IRE.core.room.addInventoryItem(gmcp.Char.Items.Add.item)
    raiseEvent("IRE.core.room.inventoryAdd",gmcp.Char.Items.Add.item)
	end
end</script>
							<eventHandlerList>
								<string>gmcp.Char.Items.Add</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>IRE.gmcp.char.items_received</name>
							<packageName></packageName>
							<script>-----
--@Description Processes gmcp.Char.Items.List, setting the local room inventory or character inventory
--@Event IRE.core.inventory.listReceived Raised when the character inventory list is processed
--@Event IRE.core.room.inventoryReceived Raised when the room inventory list is processed
-----
function IRE.gmcp.char.items_received()
	if gmcp.Char.Items.List.location == "inv" 
	then
    IRE.core.inventory.processList(gmcp.Char.Items.List.items)
    raiseEvent("IRE.core.inventory.listReceived")
  elseif gmcp.Char.Items.List.location == "room"
  then
		IRE.core.room.processInventoryList(gmcp.Char.Items.List.items)
    raiseEvent("IRE.core.room.inventoryReceived")
	end
end</script>
							<eventHandlerList>
								<string>gmcp.Char.Items.List</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>IRE.gmcp.char.items_Remove</name>
							<packageName></packageName>
							<script>-----
--@Description Processes gmcp.Char.Items.Remove, removing an item from the local room inventory or character inventory
--@Event IRE.core.inventory.remove Raised when an item is removed from character inventory.
-- Passes the item as defined by gmcp.Char.Items.Remove.item as its argument.
--@Event IRE.core.room.inventoryRemove Raised when an item is removed from the room inventory.
-- Passes the item as defined by gmcp.Char.Items.Remove.item as its argument.
-----
function IRE.gmcp.char.items_Remove()
	if gmcp.Char.Items.Remove.location == "inv"
  then
    IRE.core.inventory.removeItem(gmcp.Char.Items.Remove.item)
    raiseEvent("IRE.core.inventory.remove",gmcp.Char.Items.Remove.item)
  elseif gmcp.Char.Items.Add.location == "room"
  then
		IRE.core.room.removeInventoryItem(gmcp.Char.Items.Remove.item)
    raiseEvent("IRE.core.room.inventoryRemove",gmcp.Char.Items.Remove.item)
	end
end</script>
							<eventHandlerList>
								<string>gmcp.Char.Items.Remove</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>IRE.gmcp.char.vitals</name>
							<packageName></packageName>
							<script>function IRE.gmcp.char.vitals()
	-- set the players class
	if IRE.core.char.vitals.class == "" then IRE.core.char.vitals.class = gmcp.Char.Vitals.class end
	
	local hp = tonumber(gmcp.Char.Vitals.hp);
	local maxhp = tonumber(gmcp.Char.Vitals.maxhp);
	IRE.core.char.vitals.healthBar:setValue(hp,maxhp, "&lt;center&gt;Health: "..hp.."/"..maxhp);
	
	local resource1 = tonumber(gmcp.Char.Vitals.pt);
	local maxResource1 = tonumber(gmcp.Char.Vitals.maxpt);
	IRE.core.char.vitals.resource1Bar:setValue(resource1,maxResource1,
		"&lt;center&gt;"..resource1.."/"..maxResource1);
end</script>
							<eventHandlerList>
								<string>gmcp.Char.Vitals</string>
							</eventHandlerList>
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>IRE.core</name>
					<packageName></packageName>
					<script>------
--@Description The core module for common IRE functionality
------
IRE.core = IRE.core or {}

-----
--Events
--IRE.core.login Event thrown on character login
-----</script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>IRE.core.inventory</name>
						<packageName></packageName>
						<script>------
--@Description The core inventory module
------
IRE.core.inventory = IRE.core.inventory or {}

-----
--@Description The actual inventory table synced with GMCP.Char.Items for local access
-----
IRE.core.inventory.list = IRE.core.inventory.list or {}

-----
--Events
--IRE.core.inventory.listReceived signals a change in the inventory.
--IRE.core.inventory.add signals an addition to the inventory. Passes the item as the argument.
--IRE.core.inventory.remove signals a removal from the inventory. Passes the item as the argument.
-----

-----
--@Description Resets the inventory list and adds all items to it
--@Param itemList The item list from gmcp.Char.Items.List.items
-----
function IRE.core.inventory.processList(itemList)
  IRE.core.inventory.list = {}
  for index, item in pairs(itemList) do
    IRE.core.inventory.addItem(item)
  end
end

-----
--@Description Adds an item to the inventory list
--@Param item The item to add to the list
-----
function IRE.core.inventory.addItem(item)
  IRE.core.inventory.list[item.id] = item
end

-----
--@Description Removes an item from the inventory list
--@Param item The item to remove from the list
-----
function IRE.core.inventory.removeItem(item)
  IRE.core.inventory.list[item.id] = nil
end</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>IRE.core.inventory.login</name>
							<packageName></packageName>
							<script>-----
--@Description Sends the gmcp inventory request at login
-----
function IRE.core.inventory.login()
  sendGMCP("Char.Items.Inv")
end</script>
							<eventHandlerList>
								<string>IRE.core.login</string>
							</eventHandlerList>
						</Script>
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>IRE.core.room</name>
						<packageName></packageName>
						<script>------
--@Description The core room module
------
IRE.core.room = IRE.core.room or {}

-----
--@Description The room inventory table synced with GMCP.Char.Items for local access
-----
IRE.core.room.inventory = IRE.core.room.inventory or {}

-----
--Events
--IRE.core.room.inventoryReceived signals a change in the room inventory.
--IRE.core.room.inventoryAdd signals an addition to the room inventory. Passes the item as the argument.
--IRE.core.room.inventoryRemove signals a removal from the room inventory. Passes the item as the argument.
-----

-----
--@Description Resets the room inventory list and adds all items to it
--@Param itemList The item list from gmcp.Char.Items.List.items
-----
function IRE.core.room.processInventoryList(itemList)
  IRE.core.room.inventory = {}
  for index, item in pairs(itemList) do
    IRE.core.room.addInventoryItem(item)
  end
end

-----
--@Description Adds an item to the room inventory list
--@Param item The item to add to the list
-----
function IRE.core.room.addInventoryItem(item)
  IRE.core.room.inventory[item.id] = item
end

-----
--@Description Removes an item from the room inventory list
--@Param item The item to remove from the list
-----
function IRE.core.room.removeInventoryItem(item)
  IRE.core.room.inventory[item.id] = nil
end</script>
						<eventHandlerList />
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>IRE.core.char</name>
						<packageName></packageName>
						<script>IRE.core.char = IRE.core.char or {}</script>
						<eventHandlerList />
						<ScriptGroup isActive="yes" isFolder="yes">
							<name>IRE.core.char.vitals</name>
							<packageName></packageName>
							<script>IRE.core.char.vitals = IRE.core.char.vitals or {}</script>
							<eventHandlerList />
							<Script isActive="yes" isFolder="no">
								<name>IRE.core.char.vitalsBars</name>
								<packageName></packageName>
								<script>IRE.core.char.vitalsBars = Geyser.HBox:new({
	name = "IRE.core.char.vitalsBars",
	x = 0, y = 0,
	width = "100%",
	height = "100%"
}, vitals);

IRE.core.char.vitals.healthBar = Geyser.Gauge:new({
	name = "IRE.core.char.vitals.healthBar",
	fontSize = 8,
}, IRE.core.char.vitalsBars);

IRE.core.char.vitals.healthBar.front:setStyleSheet([[
	background-color: red;
	border-top-left-radius: 0.5em;
	border-top-right-radius: 0.5em;
	border-bottom-left-radius: 0.5em;
	border-bottom-right-radius: 0.5em;
	border: 2px solid white;
]]);

IRE.core.char.vitals.healthBar.back:setStyleSheet([[
	background-color: grey;
	opacity: 0.3;
	border-top-left-radius: 0.5em;
	border-top-right-radius: 0.5em;
	border-bottom-left-radius: 0.5em;
	border-bottom-right-radius: 0.5em;
	border: 2px solid white;
	
]]);

IRE.core.char.vitals.resource1Bar = Geyser.Gauge:new({
	name = "IRE.core.char.vitals.resource1Bar",
	fontSize = 8,
}, IRE.core.char.vitalsBars);

IRE.core.char.vitals.resource1Bar.front:setStyleSheet([[
	background-color: blue;
	border-top-left-radius: 0.5em;
	border-top-right-radius: 0.5em;
	border-bottom-left-radius: 0.5em;
	border-bottom-right-radius: 0.5em;
	border: 2px solid white;
]]);

IRE.core.char.vitals.resource1Bar.back:setStyleSheet([[
	background-color: grey;
	opacity: 0.3;
	border-top-left-radius: 0.5em;
	border-top-right-radius: 0.5em;
	border-bottom-left-radius: 0.5em;
	border-bottom-right-radius: 0.5em;
	border: 2px solid white;
	
]]);</script>
								<eventHandlerList />
							</Script>
						</ScriptGroup>
					</ScriptGroup>
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>IRE.core.comm</name>
						<packageName></packageName>
						<script>------
--@Description The core communication module
------
IRE.core.comm = IRE.core.comm or {}</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>IRE.core.comm.login</name>
							<packageName></packageName>
							<script>-----
--@Description Activates GMCP Comms
-----
function IRE.core.comm.login()
  sendGMCP([[Core.Supports.Add ["Comm.Channel 1"] ]])
end</script>
							<eventHandlerList>
								<string>IRE.core.login</string>
							</eventHandlerList>
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>IRE.core.comm.received</name>
							<packageName></packageName>
							<script>function IRE.core.comm.received(event)
  	local payload = gmcp.Comm.Channel.Text
  	local text = ansi2decho(payload.text)
  	decho("Chat", text..'\n')
end
registerAnonymousEventHandler('gmcp.Comm.Channel.Text', 'IRE.core.comm.received')</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>fText</name>
				<packageName>fText</packageName>
				<script></script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>TextFormatter</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>standaloneFormatter</name>
						<packageName></packageName>
						<script>demonnic = demonnic or {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "|cFFFFFF"
    options.spacerColor = options.spacerColor or "|cFFFFFF"
    options.textColor = options.textColor or "|cFFFFFF"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = str:gsub(options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  options.effWidth = options.width - ((options.capLen * 2) + 2)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    str = string.format(" %s ", str)
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    str = string.format(" %s", str)
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    str = string.format("%s ", str)
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  
  if options.inside then 
  --if we're placing the repated spacer inside
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="
    return options.capColor .. leftCap .. options.spacerColor.. string.rep(options.spacer, (leftPadLen - capLen)) .. options.textColor .. str .. options.spacerColor ..string.rep(options.spacer, (rightPadLen - capLen)) .. options.capColor .. rightCap
  else 
  --otherwise, it''s be the spaces on the 'inside'
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    return options.spacerColor .. string.rep(options.spacer, (leftPadLen - capLen)) .. options.capColor .. leftCap .. options.textColor .. str .. options.capColor .. rightCap .. options.spacerColor .. string.rep(options.spacer, (rightPadLen - capLen))
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>reusableFormatter</name>
						<packageName></packageName>
						<script>demonnic.TextFormatter = {
  options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  },
  validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}
}

function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. type(shouldWrap) .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. type(cap)) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. type(capColor)) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. type(spacerColor)) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. type(textColor)) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. type(spacer)) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. type(spacerInside))
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. type(shouldMirror))
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

setmetatable(demonnic.TextFormatter, demonnic.TextFormatter)
function demonnic.TextFormatter:new(options)
  me = {}
  setmetatable(me, self)
  self.__index = self
  if type(options) == "table" then
    for option,value in pairs(options) do
      me.options[option] = value
    end
  elseif option ~= nil then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  return me
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
