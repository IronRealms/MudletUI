<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>IRE</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>IRE.core</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>password trigger</name>
					<script>-----
--@Description Raises a login event upon logging in successfully
-----
raiseEvent("IRE.core.login")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Password correct. Welcome to Imperian.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="no" isFolder="no">
			<name>Drag and Drop GUI Framework</name>
			<packageName></packageName>
			<script>-- Jor'Mox's GUIframe Script
-- 10/02/2018
-- v1.3.3

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)

GUIframe.configs = GUIframe.configs or {}

GUIframe.defaults = {
    tabHeight = 20,
    tabStyle = [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color = white"&gt;',
    leftStartWidth = 0,
    leftStartHeight = halfH,
    rightStartWidth = 0,
    rightStartHeight = halfH,
    topStartHeight = 0,
    bottomStartHeight = 0,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_30t.png",
    borderOffset = 5,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo = {
    topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
        height = configs.tabHeight},
    bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
        width = configs.leftStartWidth, height = configs.tabHeight},
    topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
        width = configs.rightStartWidth, height = configs.tabHeight},
    bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
        y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
}
local containerInfo = {
    topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
        width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
    bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
        width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
    topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
        y = configs.tabHeight, width = configs.rightStartWidth,
        height = configs.rightStartHeight - configs.tabHeight},
    bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
        y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
        height = configs.rightStartHeight - configs.tabHeight},
    bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
        y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
        width = mainW - configs.leftStartWidth - configs.rightStartWidth},
    topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
        width = mainW - configs.leftStartWidth - configs.rightStartWidth}
}
local resizeInfo = {
    resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
        y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
        width = configs.resizeWidth},
    resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
        y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
        width = configs.resizeWidth},
    resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
        y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
    resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
        y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
        width = configs.resizeWidth}
}

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}
    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end
    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    setBorderRight(configs.rightStartWidth + configs.borderOffset)
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
	        tab:echo(configs.tabEchoStyle..tab.name:gsub("Tab",""))
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, wname)
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(getMudletHomeDir() .. "/GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = getMudletHomeDir() .. "/GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
        local tabs = {}
        for _,name in ipairs(wins) do
            table.insert(tabs, name.."Tab")
            GUIframe.addWindow(GUIframe.windows[name], name, con)
        end
        local tabCon = GUIframe[con].tabs
        if tabCon then
            tabCon.windows = tabs
            adjustTabs(tabCon)
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""))
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    lbl = GUIframe[name]
	    if lbl.isClicked then
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>Barebones IRE framework</name>
			<packageName></packageName>
			<script>registerAnonymousEventHandler("sysLoadEvent", "GUIframe.loadSettings")
registerAnonymousEventHandler("sysExitEvent", "GUIframe.saveSettings")
local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW / 2), math.floor(mainH / 2)
GUIframe.configs =
  {
    tabHeight = 20,
    tabStyle =
      [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color = white"&gt;',
    leftStartWidth = 450,
    leftStartHeight = halfH,
    rightStartWidth = 400,
    rightStartHeight = halfH,
    topStartHeight = 0,
    bottomStartHeight = 110,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/ire-ui/img/blue_arrows.png",
    resizeRestImage = "/ire-ui/img/blue_arrows_30t.png",
    borderOffset = 5,
  }
mapper = Geyser.Mapper:new({name = "myMapper"})
chat = Geyser.MiniConsole:new({name = "myChat"})
characterinfo =
  Geyser.Label:new(
    {
      name = "RedBox",
      color = "red",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Things about me go here&lt;/center&gt;",
    }
  )
skills =
  Geyser.Label:new(
    {
      name = "BlueBox",
      color = "blue",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Skills go here&lt;/center&gt;",
    }
  )
inventory =
  Geyser.Label:new(
    {
      name = "GreenBox",
      color = "brown",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Inventory goes here&lt;/center&gt;",
    }
  )
roominfo =
  Geyser.Label:new(
    {
      name = "OrangeBox",
      color = "orange",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Room info goes here&lt;/center&gt;",
    }
  )
online =
  Geyser.Label:new(
    {
      name = "YellowBox",
      color = "pink",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;List of online players goes here&lt;/center&gt;",
    }
  )
quests =
  Geyser.Label:new(
    {
      name = "YellowBox2",
      color = "gold",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Quests go here&lt;/center&gt;",
    }
  )
charstats =
  Geyser.Label:new(
    {
      name = "Character Stats",
      color = "grey",
      x = 0,
      y = 0,
      width = 0,
      height = 0,
      message = "&lt;center&gt;Character stats go here&lt;/center&gt;",
    }
  )
GUIframe.addWindow(mapper, "Map", "topleft")
GUIframe.addWindow(characterinfo, "Me", "bottomleft")
GUIframe.addWindow(skills, "Skills", "bottomleft")
GUIframe.addWindow(inventory, "Inventory", "bottomleft")
GUIframe.addWindow(roominfo, "Room info", "topright")
GUIframe.addWindow(online, "Online", "topright")
GUIframe.addWindow(quests, "Quests", "bottomright")
GUIframe.addWindow(chat, "Chat", "bottomright")
GUIframe.addWindow(charstats, charstats.name, "bottom")
GUIframe.disable("top", true)</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>IRE</name>
			<packageName></packageName>
			<script>------
--@Description The base namespace table for Iron Realms Entertainment
------
IRE = IRE or {}

---------
--Version
---------
IRE.version = IRE.version or {
  display = "0.1.0",
  major = 0,
  minor = 1,
  bugfix = 0
}</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>IRE.gmcp</name>
				<packageName></packageName>
				<script>------
--@Description The table for gmcp handling for iron realms games
------
IRE.gmcp = IRE.gmcp or {}</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>IRE.gmcp.char</name>
					<packageName></packageName>
					<script>------
--@Description The table for gmcp character data handling
------
IRE.gmcp.char = IRE.gmcp.char or {}</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>IRE.gmcp.char.items_add</name>
						<packageName></packageName>
						<script>-----
--@Description Processes gmcp.Char.Items.Add, adding an item to the local room inventory or character inventory
--@Event IRE.core.inventory.add Raised when the character inventory receives an item.
-- Passes the item as defined by gmcp.Char.Items.Add.item as its argument.
--@Event IRE.core.room.inventoryAdd Raised when the room inventory receives an item.
-- Passes the item as defined by gmcp.Char.Items.Add.item as its argument.
-----
function IRE.gmcp.char.items_add()
	if gmcp.Char.Items.Add.location == "inv" 
	then
		IRE.core.inventory.addItem(gmcp.Char.Items.Add.item)
    raiseEvent("IRE.core.inventory.add",gmcp.Char.Items.Add.item)
  elseif gmcp.Char.Items.Add.location == "room"
  then
		IRE.core.room.addInventoryItem(gmcp.Char.Items.Add.item)
    raiseEvent("IRE.core.room.inventoryAdd",gmcp.Char.Items.Add.item)
	end
end</script>
						<eventHandlerList>
							<string>gmcp.Char.Items.Add</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>IRE.gmcp.char.items_received</name>
						<packageName></packageName>
						<script>-----
--@Description Processes gmcp.Char.Items.List, setting the local room inventory or character inventory
--@Event IRE.core.inventory.listReceived Raised when the character inventory list is processed
--@Event IRE.core.room.inventoryReceived Raised when the room inventory list is processed
-----
function IRE.gmcp.char.items_received()
	if gmcp.Char.Items.List.location == "inv" 
	then
    IRE.core.inventory.processList(gmcp.Char.Items.List.items)
    raiseEvent("IRE.core.inventory.listReceived")
  elseif gmcp.Char.Items.List.location == "room"
  then
		IRE.core.room.processInventoryList(gmcp.Char.Items.List.items)
    raiseEvent("IRE.core.room.inventoryReceived")
	end
end</script>
						<eventHandlerList>
							<string>gmcp.Char.Items.List</string>
						</eventHandlerList>
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>IRE.gmcp.char.items_remove</name>
						<packageName></packageName>
						<script>-----
--@Description Processes gmcp.Char.Items.Remove, removing an item from the local room inventory or character inventory
--@Event IRE.core.inventory.remove Raised when an item is removed from character inventory.
-- Passes the item as defined by gmcp.Char.Items.Remove.item as its argument.
--@Event IRE.core.room.inventoryRemove Raised when an item is removed from the room inventory.
-- Passes the item as defined by gmcp.Char.Items.Remove.item as its argument.
-----
function IRE.gmcp.char.items_remove()
	if gmcp.Char.Items.Remove.location == "inv"
  then
    IRE.core.inventory.removeItem(gmcp.Char.Items.Remove.item)
    cecho(gmcp.Char.Items.Remove.item)
    raiseEvent("IRE.core.inventory.remove",gmcp.Char.Items.Remove.item)
  elseif gmcp.Char.Items.Remove.location == "room"
  then
		IRE.core.room.removeInventoryItem(gmcp.Char.Items.Remove.item)
    raiseEvent("IRE.core.room.inventoryRemove",gmcp.Char.Items.Remove.item)
	end
end</script>
						<eventHandlerList>
							<string>gmcp.Char.Items.Remove</string>
						</eventHandlerList>
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>IRE.core</name>
				<packageName></packageName>
				<script>------
--@Description The core module for common IRE functionality
------
IRE.core = IRE.core or {}

-----
--Events
--IRE.core.login Event thrown on character login
-----
IRE.core.login = IRE.core.login or {}</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>IRE.core.inventory</name>
					<packageName></packageName>
					<script>------
--@Description The core inventory module
------
IRE.core.inventory = IRE.core.inventory or {}

-----
--@Description The actual inventory table synced with GMCP.Char.Items for local access
-----
IRE.core.inventory.list = IRE.core.inventory.list or {}

-----
--Events
--IRE.core.inventory.listReceived signals a change in the inventory.
--IRE.core.inventory.add signals an addition to the inventory. Passes the item as the argument.
--IRE.core.inventory.remove signals a removal from the inventory. Passes the item as the argument.
-----

IRE.core.inventory.listReceived = IRE.core.inventory.listReceived or {}
IRE.core.inventory.add = IRE.core.inventory.add or {}
IRE.core.inventory.remove = IRE.core.inventory.remove or {}

-----
--@Description Resets the inventory list and adds all items to it
--@Param itemList The item list from gmcp.Char.Items.List.items
-----
function IRE.core.inventory.processList(itemList)
  IRE.core.inventory.list = {}
  for index, item in pairs(itemList) do
    IRE.core.inventory.addItem(item)
  end
end

-----
--@Description Adds an item to the inventory list
--@Param item The item to add to the list
-----
function IRE.core.inventory.addItem(item)
  IRE.core.inventory.list[item.id] = item
end

-----
--@Description Removes an item from the inventory list
--@Param item The item to remove from the list
-----
function IRE.core.inventory.removeItem(item)
  IRE.core.inventory.list[item.id] = nil
end</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>IRE.core.inventory.login</name>
						<packageName></packageName>
						<script>-----
--@Description Sends the gmcp inventory request at login
-----
function IRE.core.inventory.login()
  sendGMCP("Char.Items.Inv")
end</script>
						<eventHandlerList>
							<string>IRE.core.login</string>
						</eventHandlerList>
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>IRE.core.room</name>
					<packageName></packageName>
					<script>------
--@Description The core room module
------
IRE.core.room = IRE.core.room or {}

-----
--@Description The room inventory table synced with GMCP.Char.Items for local access
-----
IRE.core.room.inventory = IRE.core.room.inventory or {}

-----
--Events
--IRE.core.room.inventoryReceived signals a change in the room inventory.
--IRE.core.room.inventoryAdd signals an addition to the room inventory. Passes the item as the argument.
--IRE.core.room.inventoryRemove signals a removal from the room inventory. Passes the item as the argument.
-----
IRE.core.room.inventoryReceived = IRE.core.room.inventoryReceived or {}
IRE.core.room.inventoryAdd = IRE.core.room.inventoryAdd or {}
IRE.core.room.inventoryRemove = IRE.core.room.inventoryRemove or {}

-----
--@Description Resets the room inventory list and adds all items to it
--@Param itemList The item list from gmcp.Char.Items.List.items
-----
function IRE.core.room.processInventoryList(itemList)
  IRE.core.room.inventory = {}
  for index, item in pairs(itemList) do
    IRE.core.room.addInventoryItem(item)
  end
end

-----
--@Description Adds an item to the room inventory list
--@Param item The item to add to the list
-----
function IRE.core.room.addInventoryItem(item)
  IRE.core.room.inventory[item.id] = item
end

-----
--@Description Removes an item from the room inventory list
--@Param item The item to remove from the list
-----
function IRE.core.room.removeInventoryItem(item)
  IRE.core.room.inventory[item.id] = nil
end</script>
					<eventHandlerList />
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>NumpadNavigation</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>-1</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 1</name>
				<packageName></packageName>
				<script>send("sw")
raiseEvent("IRE.NumpadNavigation.attemptMove","sw")</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 2</name>
				<packageName></packageName>
				<script>send("s")
raiseEvent("IRE.NumpadNavigation.attemptMove","s")</script>
				<command></command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 3</name>
				<packageName></packageName>
				<script>send("se")
raiseEvent("IRE.NumpadNavigation.attemptMove","se")</script>
				<command></command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 4</name>
				<packageName></packageName>
				<script>send("w")
raiseEvent("IRE.NumpadNavigation.attemptMove","w")</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 5</name>
				<packageName></packageName>
				<script>send("look")
raiseEvent("IRE.NumpadNavigation.attemptLook")</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 6</name>
				<packageName></packageName>
				<script>send("e")
raiseEvent("IRE.NumpadNavigation.attemptMove","e")</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 7</name>
				<packageName></packageName>
				<script>send("nw")
raiseEvent("IRE.NumpadNavigation.attemptMove","nw")</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 8</name>
				<packageName></packageName>
				<script>send("n")
raiseEvent("IRE.NumpadNavigation.attemptMove","n")</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding 9</name>
				<packageName></packageName>
				<script>send("ne")
raiseEvent("IRE.NumpadNavigation.attemptMove","ne")</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding +</name>
				<packageName></packageName>
				<script>send("down")
raiseEvent("IRE.NumpadNavigation.attemptMove","down")</script>
				<command></command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding -</name>
				<packageName></packageName>
				<script>send("up")
raiseEvent("IRE.NumpadNavigation.attemptMove","up")</script>
				<command></command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding /</name>
				<packageName></packageName>
				<script>send("in")
raiseEvent("IRE.NumpadNavigation.attemptMove","in")</script>
				<command></command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Keybinding *</name>
				<packageName></packageName>
				<script>send("out")
raiseEvent("IRE.NumpadNavigation.attemptMove","out")</script>
				<command></command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
